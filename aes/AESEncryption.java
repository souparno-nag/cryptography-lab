import java.util.Arrays;
import java.util.Scanner;

public class AESEncryption {
    private final int Nk, Nr;
    private final byte[] roundKey;

    public AESEncryption(byte[] key, int mode) {
        if (mode == 1 && key.length == 16) { Nk = 4; Nr = 10; }
        else if (mode == 2 && key.length == 24) { Nk = 6; Nr = 12; }
        else if (mode == 3 && key.length == 32) { Nk = 8; Nr = 14; }
        else throw new IllegalArgumentException("Key must be 16, 24, or 32 bytes");
        roundKey = keyExpansion(key);
    }

    /* ======================= PUBLIC API ======================= */

    public byte[] encryptBlock(byte[] in) {
        byte[][] s = toState(in);
        addRoundKey(s,0);
        for(int r=1;r<Nr;r++){ subBytes(s); shiftRows(s); mixColumns(s); addRoundKey(s,r); }
        subBytes(s); shiftRows(s); addRoundKey(s,Nr);
        return fromState(s);
    }

    public byte[] decryptBlock(byte[] in) {
        byte[][] s = toState(in);
        addRoundKey(s,Nr);
        for(int r=Nr-1;r>0;r--){ invShiftRows(s); invSubBytes(s); addRoundKey(s,r); invMixColumns(s); }
        invShiftRows(s); invSubBytes(s); addRoundKey(s,0);
        return fromState(s);
    }

    /* ======================= CORE ======================= */

    private byte[][] toState(byte[] in){
        byte[][] s=new byte[4][4];
        for(int i=0;i<16;i++) s[i%4][i/4]=in[i];
        return s;
    }
    private byte[] fromState(byte[][] s){
        byte[] out=new byte[16];
        for(int i=0;i<16;i++) out[i]=s[i%4][i/4];
        return out;
    }

    private void addRoundKey(byte[][] s,int r){
        int off=r*16;
        for(int c=0;c<4;c++)for(int i=0;i<4;i++) s[i][c]^=roundKey[off+4*c+i];
    }

    private void subBytes(byte[][] s){
        for(int i=0;i<4;i++)for(int j=0;j<4;j++) s[i][j]=(byte)SBOX[s[i][j]&0xFF];
    }
    private void invSubBytes(byte[][] s){
        for(int i=0;i<4;i++)for(int j=0;j<4;j++) s[i][j]=(byte)INV_SBOX[s[i][j]&0xFF];
    }

    private void shiftRows(byte[][] s){
        for(int r=1;r<4;r++) s[r]=rotL(s[r],r);
    }
    private void invShiftRows(byte[][] s){
        for(int r=1;r<4;r++) s[r]=rotR(s[r],r);
    }

    private void mixColumns(byte[][] s){
        for(int c=0;c<4;c++){
            byte a0=s[0][c],a1=s[1][c],a2=s[2][c],a3=s[3][c];
            s[0][c]=(byte)(mul2(a0)^mul3(a1)^a2^a3);
            s[1][c]=(byte)(a0^mul2(a1)^mul3(a2)^a3);
            s[2][c]=(byte)(a0^a1^mul2(a2)^mul3(a3));
            s[3][c]=(byte)(mul3(a0)^a1^a2^mul2(a3));
        }
    }
    private void invMixColumns(byte[][] s){
        for(int c=0;c<4;c++){
            byte a0=s[0][c],a1=s[1][c],a2=s[2][c],a3=s[3][c];
            s[0][c]=(byte)(mul14(a0)^mul11(a1)^mul13(a2)^mul9(a3));
            s[1][c]=(byte)(mul9(a0)^mul14(a1)^mul11(a2)^mul13(a3));
            s[2][c]=(byte)(mul13(a0)^mul9(a1)^mul14(a2)^mul11(a3));
            s[3][c]=(byte)(mul11(a0)^mul13(a1)^mul9(a2)^mul14(a3));
        }
    }

    /* ======================= KEY SCHEDULE ======================= */

    private byte[] keyExpansion(byte[] key){
        int words=4*(Nr+1);
        byte[] w=new byte[words*4];
        System.arraycopy(key,0,w,0,key.length);
        byte[] temp=new byte[4];
        int i=Nk;
        while(i<words){
            for(int j=0;j<4;j++) temp[j]=w[4*(i-1)+j];
            if(i%Nk==0){ temp=subWord(rotWord(temp)); temp[0]^=RCON[i/Nk]; }
            else if(Nk>6 && i%Nk==4){ temp=subWord(temp); }
            for(int j=0;j<4;j++) w[4*i+j]=(byte)(w[4*(i-Nk)+j]^temp[j]);
            i++;
        }
        return w;
    }

    private byte[] rotWord(byte[] w){ return new byte[]{w[1],w[2],w[3],w[0]}; }
    private byte[] subWord(byte[] w){ for(int i=0;i<4;i++) w[i]=(byte)SBOX[w[i]&0xFF]; return w; }

    /* ======================= GF(2^8) ======================= */

    private byte mul2(byte b){ int x=b&0xFF; x=(x<<1)^((x&0x80)!=0?0x1B:0); return (byte)x; }
    private byte mul3(byte b){ return (byte)(mul2(b)^b); }
    private byte mul9(byte b){ return (byte)(mul2(mul2(mul2(b)))^b); }
    private byte mul11(byte b){ return (byte)(mul2(mul2(mul2(b)))^mul2(b)^b); }
    private byte mul13(byte b){ return (byte)(mul2(mul2(mul2(b)))^mul2(mul2(b))^b); }
    private byte mul14(byte b){ return (byte)(mul2(mul2(mul2(b)))^mul2(mul2(b))^mul2(b)); }

    private byte[] rotL(byte[] a,int n){
        byte[] r=new byte[4];
        for(int i=0;i<4;i++) r[i]=a[(i+n)%4];
        return r;
    }
    private byte[] rotR(byte[] a,int n){
        byte[] r=new byte[4];
        for(int i=0;i<4;i++) r[(i+n)%4]=a[i];
        return r;
    }

    /* ======================= TABLES ======================= */

    private static final int[] SBOX = {
        0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
        0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
        0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
        0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
        0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
        0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
        0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
        0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
        0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
        0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
        0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
        0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
        0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
        0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
        0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
        0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16
    };

    private static final int[] INV_SBOX = {
        0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,
        0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,
        0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,
        0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,
        0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,
        0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,
        0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,
        0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,
        0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,
        0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,
        0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,
        0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,
        0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,
        0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,
        0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,
        0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D
    };

    private static final byte[] RCON = {
        0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,(byte)0x80,0x1B,0x36
    };

    /* PADDING */

    public static byte[] pad(byte[] in) {
        int pad = 16 - (in.length % 16);
        byte[] out = Arrays.copyOf(in, in.length + pad);
        for(int i=in.length;i<out.length;i++) out[i]=(byte)pad;
        return out;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        try {
            System.out.print("Enter key: ");
            byte[] key = sc.nextLine().getBytes("UTF-8");
            System.out.print("Enter message: ");
            byte[] msg = sc.nextLine().getBytes("UTF-8");
            key = Arrays.copyOf(key, 16);
            AESEncryption aes = new AESEncryption(key, 1);
            byte[] padded = pad(msg);
            byte[] cipher = new byte[padded.length];

            for(int i=0;i<padded.length;i+=16)
                System.arraycopy(aes.encryptBlock(Arrays.copyOfRange(padded,i,i+16)),0,cipher,i,16);
            System.out.println("Encrypted: "+Arrays.toString(cipher));

            byte[] plain = new byte[cipher.length];
            for(int i=0;i<cipher.length;i+=16)
                System.arraycopy(aes.decryptBlock(Arrays.copyOfRange(cipher,i,i+16)),0,plain,i,16);
            int p = plain[plain.length-1] & 0xFF;
            plain = Arrays.copyOf(plain, plain.length-p);
            System.out.println("Decrypted: "+new String(plain,"UTF-8"));
                    } catch (Exception e) {
            e.printStackTrace();
        }
        sc.close();
    }
}
